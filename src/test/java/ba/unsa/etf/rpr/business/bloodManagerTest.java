package ba.unsa.etf.rpr.business;
import ba.unsa.etf.rpr.Dao.BloodDaoSQLImpl;
import ba.unsa.etf.rpr.Dao.DaoFactory;
import ba.unsa.etf.rpr.Domain.Blood;
import ba.unsa.etf.rpr.Domain.Hospital;
import ba.unsa.etf.rpr.Exceptions.BloodException;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import java.sql.Date;
import java.time.LocalDate;
/**
 * @author Azra Žunić
 * version 1.0
 */
public class bloodManagerTest {
    BloodManager bloodManager;
    private Blood blood;

    /**
     * This method will be called before each test method
     */
    @BeforeEach
    public void initializeObjectsWeNeed(){
        bloodManager = new BloodManager();
        blood = new Blood();
        blood.setId(50);
        blood.setBloodGroup("Blood Type");
        blood.setBloodAmount(500);
        blood.setBloodBagNumber("WER-7-GH");
        blood.setDonateDate(Date.valueOf(LocalDate.now()));
    }
    /**
     * In this method we will test validateBloodType(String group) for correct and incorrect passed parameters
     */
    @Test
    void validateBloodType() {
        String correctGroup = "Blood group";
        try {
            bloodManager.validateBloodType(correctGroup);
        } catch (BloodException e) {
            //Test will fall if method validateCategoryName(name) throws an exception for correct parameter
            e.printStackTrace();
            Assertions.assertTrue(false);
        }

        String incorrectNameShort = "A";
        BloodException bloodException1 = Assertions.assertThrows(BloodException.class, () -> {
            bloodManager.validateBloodType(incorrectNameShort);}, "Blood type must contain between 2 and 3 characters");
        Assertions.assertEquals("Blood type must contain between 2 and 3 characters", bloodException1.getMessage());

        String incorrectNameLong = RandomStringUtils.randomAlphabetic(50);
        BloodException bloodException2 = Assertions.assertThrows(BloodException.class, () -> {
            bloodManager.validateBloodType(incorrectNameLong);}, "Blood type must contain between 2 and 3 characters");
        Assertions.assertEquals("Blood type must contain between 2 and 3 characters", bloodException2.getMessage());
    }
    /**
     * We are testing add() method
     */
    @Test
    void add() {
        BloodDaoSQLImpl bloodDaoSQL = Mockito.mock(BloodDaoSQLImpl.class);
        MockedStatic<DaoFactory> daoFactoryMockedStatic = Mockito.mockStatic(DaoFactory.class);
        daoFactoryMockedStatic.when(DaoFactory::bloodDao).thenReturn(bloodDaoSQL);
        /**
        * An exception will be thrown because our instance of Blood.java class has value for id
         */
        BloodException bloodException = Assertions.assertThrows(BloodException.class, () -> {
            bloodManager.add(blood);}, "Can't add blood group with ID. ID is autogenerated");
        Assertions.assertEquals("Can't add blood group with ID. ID is autogenerated", bloodException.getMessage());

        blood.setId(0);

        try {
            bloodManager.add(blood);
            Assertions.assertTrue(true);
        } catch (BloodException e) {
            throw new RuntimeException(e);
        }
        daoFactoryMockedStatic.verify(DaoFactory::bloodDao);
        daoFactoryMockedStatic.close();
    }

    /**
     * Testing if we can add a blood id that is already in the table
     */
//    @Test
//    public void add2(){
//        BloodDaoSQLImpl bloodDaoSQL = BloodDaoSQLImpl.getInstance();
//        try {
//            bloodDaoSQL.add(blood);
//            Assertions.assertTrue(false);
//        } catch (BloodException e) {
//            Assertions.assertTrue(true);
//        }
//    }
}
