package ba.unsa.etf.rpr.business;
import ba.unsa.etf.rpr.Dao.BloodDaoSQLImpl;
import ba.unsa.etf.rpr.Dao.DonorDaoSQLImpl;
import ba.unsa.etf.rpr.Dao.DaoFactory;
import ba.unsa.etf.rpr.Domain.Blood;
import ba.unsa.etf.rpr.Domain.Donor;
import ba.unsa.etf.rpr.Exceptions.BloodException;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import java.sql.Date;
import java.time.LocalDate;
/**
 * @author Azra Žunić
 * version 1.0
 */
public class donorManagerTest {
DonorManager donorManager;
private Donor donor;
    /**
     * This method will be called before each test method
     */
    @BeforeEach
    public void initializeObjectsWeNeed(){
        donorManager = new DonorManager();
        donor = new Donor();
        donor.setId(50);
        donor.setFullName("Nađa Kovačević");
        donor.setGender("F");
        donor.setPhoneNumber(61147852);
        donor.setPassword("nadjak");
        donor.setAlreadyDonated("YES");
        //donor.setDateOfBirth(Date.valueOf(LocalDate.now()));
    }
    /**
     * In this method we will test validateBloodType(String group) for correct and incorrect passed parameters
     */
    @Test
    void validateDonated() {
        String correctValue = "YES";
        try {
            donorManager.validateDonated(correctValue);
        } catch (BloodException e) {
            //Test will fall if method validateDonated(name) throws an exception for correct parameter
            e.printStackTrace();
            Assertions.assertTrue(false);
        }

        String incorrectNameShort = "A";
        BloodException donorException1 = Assertions.assertThrows(BloodException.class, () -> {
            donorManager.validateDonated(incorrectNameShort);}, "Describing field already donated only with values YES or NO");
        Assertions.assertEquals("Describing field already donated only with values YES or NO", donorException1.getMessage());

        String incorrectNameLong = RandomStringUtils.randomAlphabetic(50);
        BloodException donorException2 = Assertions.assertThrows(BloodException.class, () -> {
            donorManager.validateDonated(incorrectNameLong);}, "Describing field already donated only with values YES or NO");
        Assertions.assertEquals("Describing field already donated only with values YES or NO", donorException2.getMessage());
    }
    /**
     * We are testing add() method
     */
    @Test
    void add() {
        DonorDaoSQLImpl donorDaoSQL = Mockito.mock(DonorDaoSQLImpl.class);
        MockedStatic<DaoFactory> daoFactoryMockedStatic = Mockito.mockStatic(DaoFactory.class);
        daoFactoryMockedStatic.when(DaoFactory::donorDao).thenReturn(donorDaoSQL);
        /**
         * An exception will be thrown because our instance of Donor.java class has value for id
         */
        BloodException bloodException = Assertions.assertThrows(BloodException.class, () -> {
            donorManager.add(donor);}, "Can't add donor with ID. ID is autogenerated");
        Assertions.assertEquals("Can't add donor with ID. ID is autogenerated", bloodException.getMessage());

        donor.setId(0);

        try {
            donorManager.add(donor);
            Assertions.assertTrue(true);
        } catch (BloodException e) {
            throw new RuntimeException(e);
        }
        daoFactoryMockedStatic.verify(DaoFactory::donorDao);
        daoFactoryMockedStatic.close();
    }

    /**
     * Testing if we can add a donor id that is already in the table
     */
    @Test
    public void add2(){
        DonorDaoSQLImpl donorDaoSQL = DonorDaoSQLImpl.getInstance();
        try {
            donorDaoSQL.add(donor);
            Assertions.assertTrue(false);
        } catch (BloodException e) {
            Assertions.assertTrue(true);
        }
    }
}
